
After successfully setting up real-time messaging with SignalR, I worked on persisting chat messages in a database, so they are saved even after the application restarts, and add functionality to notify all users when a new participant joins or leaves the chat. To further enrich the chat experience, I enabled users to send rich media like images and videos, as well as private messages for more personal conversations.
As the app grew, I introduced pagination for message history, giving users the ability to load previous messages on demand. Additionally, I allowed users to create profiles with avatars and display names, enhancing personalization. To ensure the app remains reliable, I implemented proper error handling and validation, as well as unit and integration tests to catch any potential issues.
Once the app is feature-rich and stable, I deployed it to a cloud platform, ensuring that itâ€™s accessible and scalable. Finally, I  addressed security enhancements, including rate-limiting and HTTPS support, to safeguard users and data.
Some Initial HouseKeeping
To prevent conflicts with project 1 where IdentityDbContext was the default DbContext I deleted the existing database and migrations from the previous project. 
Start Fresh: Delete Database and Migrations from Project 1.
Delete the existing ChatApp.db database.
Delete the Migrations folder from your project.

Persistent storage for messages
Creating Message Class

In the initial phase of the project, storing messages as simple strings was sufficient. However, as I wanted messages to remain between logins, I needed to store messages in a database, and to do this they needed to be stored in objects. To facilitate this, I created a Message class designed to hold and transport message data. This class enabled Entity Framework (EF) to map the data into a database table named Message.
To keep the project organized, I placed the Message.cs file in a newly created Models folder.

namespace ChatApp.Models
{
    public class Message
    {
        public int Id { get; set; } // Primary key
        public string User { get; set; } // Username of the sender
        public string Content { get; set; } // The actual message content
        public DateTime Timestamp { get; set; } // When the message was sent
    }
}


WIth the message objects now having a template to be created, a database is required to store  these message â€˜boxes, so they can be reintroduced between sessionsâ€™. Since messages are not provided out of the box (a custom entity), setting up the AppDbContext with Entity Framework Core is the recommended approach. 

Creating the AppDbContext:
In the previous project, we were using IdentityDbContext<IdentityUser> directly to handle Identity-related functionality like user management and authentication. Thus this became the de facto DbContext. However, now we need to store  a custom entity,  messages, in our database. To achieve this while still maintaining Identity's functionality, we create an AppDbContext that inherits from IdentityDbContext<IdentityUser>.
By doing this, the AppDbContext automatically includes all the properties and methods provided by IdentityDbContext (such as handling users, roles, and authentication data), but it also allows us to extend the context by adding custom tables for other entities, such as Messages. This means that we can leverage ASP.NET Core Identity's built-in features for user management while still creating our own database tables.
AppDbContext.cs
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using ChatApp.Models;

namespace ChatApp
{
        public class AppDbContext : IdentityDbContext<IdentityUser>
   {
      public DbSet<Message> Messages { get; set; }

    public AppDbContext(DbContextOptions<AppDbContext> options)
        : base(options)
       {
       }
         }
}


After creating the Message class, the DbSet<Message> property in the AppDbContext class is essential because it informs Entity Framework (EF) that the Message entity should be included in the database context. This allows EF to map the Message class to a corresponding database table and enables operations such as querying, adding, updating, and deleting messages within the application. The DbSet<Message> acts as a bridge between the code and the database, providing a way to manage the Messages table using LINQ queries and EF methods. Without this property, EF would not create or interact with the Messages table, making it impossible to perform database operations on the Message entity.
The using Microsoft.AspNetCore.Identity.EntityFrameworkCore; directive is now needed in AppDbContext.cs because AppDbContext inherits from IdentityDbContext<IdentityUser>. This integration requires the directive in AppDbContext.cs, but it's no longer needed in Program.cs since it's not directly referenced there anymore. So we can delete the using EntityFrameworkCore in Program.cs now.
Also now that AppDbContext inherits from IdentityDbContext, we can replace IdentityDbContext with our custom AppDbContext when registering the database context service, in Program.cs. This allows the application to handle both Identity functionality and any custom entities, like messages, in one unified database context.
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlite(builder.Configuration.GetConnectionString("DefaultConnection")));

The AddIdentity method integrates ASP.NET Core Identity into the application, enabling user authentication and authorization. By specifying AddEntityFrameworkStores<AppDbContext>, you replace the default IdentityDbContext with your custom AppDbContext as the data store for Identity. This allows AppDbContext to manage both the default Identity tables (like AspNetUsers and AspNetRoles) and any custom entities, such as messages, in a unified database context.
builder.Services.AddIdentity<IdentityUser, IdentityRole>()
    .AddEntityFrameworkStores<AppDbContext>()
    .AddDefaultTokenProviders();

This configuration ensures that Identity works seamlessly with your custom database context, enabling you to extend the schema while preserving built-in authentication and user management functionality.







Migrations



*** Make sure you save any updates to AppDbContext before migrating, this tripped me a few times ***

After creating the Message and AppDbContext classes and registering the new DbContext in Program.cs, run migrations to create the Messages table in the database:

dotnet ef migrations add AddMessagesTable 





Migration Check



dotnet ef database update 



I had to update the ChatHub to integrate with the new Message class and database. ChatApp.Models ensures access to the Message class, while using Microsoft.AspNetCore.SignalR provided the Hub class and related SignalR functionality. The class uses dependency injection to initialize AppDbContext, allowing interaction with the database. In the SendMessage method, a new Message object is created with the user's input and a UTC timestamp, added to the Messages table, and saved asynchronously. Finally, the message is broadcast to all connected clients using SignalR's Clients.All.SendAsync method.

using ChatApp.Models; 
using Microsoft.AspNetCore.SignalR;

namespace ChatApp.Hubs
{
    public class ChatHub : Hub
    {
        private readonly AppDbContext _context;

        public ChatHub(AppDbContext context)
        {
            _context = context;
        }

        public async Task SendMessage(string user, string message)
        {
            // Create a new message object
            var newMessage = new Message
            {
                User = user,
                Content = message,
                Timestamp = DateTime.UtcNow
            };

            // Add the new message to the Messages table
            _context.Messages.Add(newMessage);
            await _context.SaveChangesAsync();

            // Broadcast the message to all connected clients
            await Clients.All.SendAsync("ReceiveMessage", user, message);
        }
    }
}




As the project grew, I added a namespace to ChatHub.cs to improve code organization and make it easier to manage as the application expands. Using namespaces helps group related classes together, reduces naming conflicts, and makes the code more maintainable. Due to this change, I now need to add using ChatApp.Hubs to Program.cs and Chat.cshtml.cs in order to reference ChatHub correctly in those files.
The part in chat.cshtml coding for message display, had to be updated because when displaying messages from the database, each @message in the loop is an object from the Message class, not a simple string. Razor cannot automatically render an object as meaningful text, so we had to explicitly specify which properties, like User, Content, and Timestamp, to display.
Previously, when the database wasnâ€™t being used and I was dealing with plain strings or JavaScript-rendered messages, which Razor can easily render without extra configuration. 
<ul id="messagesList">
    @foreach (var message in Model.Messages)
    {
        <li><strong>@message.User</strong>: @message.Content (@message.Timestamp)</li>
    }
</ul>

Update Chat.cshtml.cs 
When I updated the HTML in the Razor Chat Page to display additional details for each message, such as User, Content, and Timestamp, the Page began expecting each item in Model.Messages to be a Message object with those specific properties. Previously, the Razor Page displayed only plain strings, so the Messages property in the ChatModel was defined as List<string>. However, after the HTML change, a mismatch occurred because a string does not have properties like User or Content. To resolve this, I updated the Messages property in the model to List<Message> so it could provide the Message objects required by the Razor Page. This ensured that the model and the view remained consistent, allowing the Razor Page to access the necessary data while preventing type mismatches or compilation errors.
Youâ€™ll now need to integrate the Hubs & Model folders
using ChatApp.Models;
using ChatApp.Hubs;

Update Message property to use Message type.
 public List<Message> Messages { get; set; }

Update ChatModel constructor to store Message objects in list instead of strings.
  Messages = new List<Message>();

Remove this:
            // Example: Adding a message for testing
            Messages.Add("Welcome to the chat room!");
In the updated ChatModel, I first injected the AppDbContext into the constructor to allow access to the database within the page model. I updated the OnGetAsync method to asynchronously fetch all messages from the database and populate the Messages list, which will be displayed on the chat page. 
In the OnPostSendMessageAsync method, I created a new Message object, setting the content, sender, and timestamp. This message is then added to the Messages DbSet and saved to the database using the SaveChangesAsync method. After saving, the message list is reloaded from the database to update the chat interface, and the page is refreshed to show the new message. These changes ensure that messages are persistently stored in the database and that the chat interface remains up-to-date.
The Messages variable is assigned a list of messages retrieved from the database and ordered by their Timestamp to maintain chronological order. The ChatModel constructor is updated to take an instance of the AppDbContext and initiate it. Itâ€™s then used when OnGet is called to retrieve messages from the database.
 Additionally, SignalR is set up to send a welcome message to all connected clients via the SendAsync method. 
Integrating the DbContext with the Chat Model
// usingâ€¦.

//namespace

    public class ChatModel : PageModel
    {
        private readonly AppDbContext _context;
       //other properties
        // Constructor with Dependency Injection
        public ChatModel(AppDbContext context, IHubContext<ChatHub> hubContext)
        {
            _context = context;
            _hubContext = hubContext;         

            Messages = new List<Message>();
        }

        public void OnGet()
        {
            Messages = _context.Messages.OrderBy(m => m.Timestamp).ToList();

            // Check if the SignalR hub context is available
         if (_hubContext != null)
           {
    // Send a message to all connected clients via SignalR
        _hubContext.Clients.All.SendAsync("ReceiveMessage", "Server", 
            "Welcome to the chat!");
          }
        else
          {
    Console.WriteLine("SignalR context is not available.");
          }
        }
    }
}

Message sent by client saves successfully to Messages Table in Database


Flow Overview: Enabling Persistent Messages in the ChatApp
Message Class Creation
A Message class is created to define the structure for storing, modifying, and transferring message data. This serves as the blueprint for the database table.
AppDbContext Setup
The AppDbContext is created to instruct Entity Framework (EF) about the database tables (via the DbSet<Message> property) and to provide an access point for querying and saving data.
The DbSet<Message> directly maps to the Messages table, demonstrating Object-Oriented Programming (OOP) principles and database management in action.
Database Context Registration
AddDbContext<AppDbContext> in Program.cs registers the AppDbContext with the app's Dependency Injection (DI) container.
.AddEntityFrameworkStores<AppDbContext> specifies that EF should use this context for database management, enabling Identity and other EF features.
ChatHub Integration
The ChatHub class is updated to include a reference to AppDbContext.
When the SendMessage method is called, messages are not only sent to connected clients via SignalR but also saved to the database using _context.Messages.Add(newMessage); followed by _context.SaveChangesAsync().
Fetching and Displaying Messages
The ChatModel includes an OnGet() method to retrieve all messages from the database. It uses _context.Messages.OrderBy(m => m.Timestamp).ToList() to fetch and order messages chronologically.
In Chat.cshtml, the Messages collection is iterated to display each message on the user interface.

<--------------------------------------------------------------------------------------------------------------------------->
Show when users join or leave the chat
Update Client-Side JavaScript
Listen for UserJoined and UserLeft events in your JavaScript to update the UI dynamically.
Updated JavaScript in chat.cshtml:
connection.on("UserJoined", function (user) {
    const msg = `${user} has joined the chat.`;
    const li = document.createElement("li");
    li.textContent = msg;
    document.getElementById("messagesList").appendChild(li);
});

connection.on("UserLeft", function (user) {
    const msg = `${user} has left the chat.`;
    const li = document.createElement("li");
    li.textContent = msg;
    document.getElementById("messagesList").appendChild(li);
});



I needed a way to effectively manage and display online users in a real-time chat application using SignalR. To achieve this, I created a static HashSet<string> called OnlineUsers to efficiently track users currently online, ensuring no duplicates while maintaining thread safety. When a user connected, the OnConnectedAsync method retrieved their name from Context.User?.Identity?.Name, added it to the OnlineUsers list, and notified all clients that the user had joined. It also sent the updated list of online users to the newly connected client to ensure they had the most current information. Similarly, when a user disconnected, the OnDisconnectedAsync method removed their name from the list and broadcast to all clients that the user had left, keeping the list accurate. Finally, I implemented a GetOnlineUsers method to allow clients to request the current list of online users, which was sent back to the caller. By broadcasting events such as UserJoined and UserLeft, I ensured all clients were immediately updated with changes, creating a seamless and real-time user experience.
Updated ChatHub.cs with online user configuration
//usingâ€¦

namespace ChatApp.Hubs
{
        public class ChatHub : Hub
    {
        // Other dependencies
        
// Static collection to track online users
        private static readonly HashSet<string> OnlineUsers = new();

       //constructor

       //message handling

       #region Connection Lifecycle Management

        /// <summary>
        /// Handles actions when a user connects to the hub.
        /// </summary>
        public override async Task OnConnectedAsync()
        {
            string userName = Context.User?.Identity?.Name;

            if (!string.IsNullOrEmpty(userName))
            {
                OnlineUsers.Add(userName);
                // Notify all clients that a user has joined
                await Clients.All.SendAsync("UserJoined", userName);
                // Send the updated online users list to the caller
                await Clients.Caller.SendAsync("OnlineUsers", OnlineUsers);
            }

            await base.OnConnectedAsync();
        }

        /// <summary>
        /// Handles actions when a user disconnects from the hub.
        /// </summary>
        /// <param name="exception">Optional exception if the disconnection was caused by an error.</param>
        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            string userName = Context.User?.Identity?.Name;

            if (!string.IsNullOrEmpty(userName))
            {
                OnlineUsers.Remove(userName);
                // Notify all clients that a user has left
                await Clients.All.SendAsync("UserLeft", userName);
            }

            await base.OnDisconnectedAsync(exception);
        }

        #endregion

        #region User Management

        /// <summary>
        /// Retrieves the list of currently online users.
        /// </summary>
        public Task GetOnlineUsers()
        {
            return Clients.Caller.SendAsync("OnlineUsers", OnlineUsers);
        }

        #endregion
    }
}

The line string userName = Context.User?.Identity?.Name; retrieves the username of the currently authenticated user from the SignalR connection. ChatHub knows the signed-in user because it has access to AppDbContext, which is injected into the hub. AppDbContext leverages ASP.NET Identity functionality to manage user authentication and store user details, including the username. Context.User represents the currently authenticated user and contains their identity information, such as the username, which is accessed through Context.User.Identity.Name. The ?. syntax ensures that if any part of the chain (User, Identity, or Name) is null, the code won't throw an exception and will return null instead. This setup enables ChatHub to track and manage users in real-time, such as adding or removing them from the list of online users.
Update javascript


connection.on("OnlineUsers", function (users) {
    const userList = document.getElementById("onlineUsers");
    userList.innerHTML = ""; // Clear the list
    users.forEach(function (user) {
        const li = document.createElement("li");
        li.textContent = user;
        userList.appendChild(li);
    });
});

// Request online users on connection start
connection.start().then(() => {
    connection.invoke("GetOnlineUsers");
}).catch(err => console.error(err.toString()));

When a user connects to the ChatHub, the OnConnectedAsync() method is triggered, which adds the user's name to the OnlineUsers collection and sends the updated list of online users to all connected clients. In the JavaScript, the connection.on("OnlineUsers", ...) method listens for the "OnlineUsers" event from the server. When this event is triggered, the client receives the list of online users and updates the UI by clearing the current list and appending each username as a new list item. Additionally, after establishing the SignalR connection with connection.start(), the client requests the current list of online users by invoking the GetOnlineUsers method, which prompts the server to send the latest list back to the client. This setup ensures that the clientâ€™s list of online users is always synchronized with the server as users join or leave the chat.
Update chat.cshtml to remove the user input and display the signed-in user's name:

<!-- Display online users -->
<h3>Online Users</h3>
<ul id="onlineUsers"></ul>


// Get the signed-in user's name from the Razor page model
const user = "@User.Identity.Name"; // Uses the logged-in user's name from the server-side model

â†â€”------------------------------------------------------------------------------------------------------------------->
Handling file uploads in a Razor Page API
File Input and Button in HTML
I had to add an input form in the html to allow clients upload a file. The method was post which â€˜knowsâ€™ to trigger post related methods in the pageâ€™s Model. 
*** Donâ€™t forget the anti forgery token for all Post requests***
<form id="uploadForm" method="post" enctype="multipart/form-data" asp-antiforgery="true" action="/Chat">
    @Html.AntiForgeryToken()
    <input type="file" name="file" />
    <button type="submit">Upload File</button>
</form>

JavaScript File Upload Logic
Add this segment inside your <script> block in the Chat.cshtml file:
 // #region Form Submission Handling
document.addEventListener("DOMContentLoaded", function () {
    const uploadForm = document.querySelector("#uploadForm");
    console.log("DOM loaded, looking for the upload form...");

    if (uploadForm) {
        console.log("Upload form found. Adding submit event listener.");

        uploadForm.addEventListener("submit", function (event) {
            event.preventDefault(); // Prevent the default form submission
            console.log("Form submission intercepted.");

            const formData = new FormData(uploadForm);
            console.log("Form data created:", formData);

            // Debugging: Log the form data before sending the request
            for (let [key, value] of formData.entries()) {
                console.log(`Key: ${key}, Value: ${value}`);
            }

            fetch(uploadForm.action, {
                method: "POST",
                body: formData
            })
                .then(response => {
                    console.log("Response received:", response);
                    return response.text();
                })
                .then(data => {
                    console.log("Server response data:", data);
                    alert("File uploaded successfully!");
                })
                .catch(error => {
                    console.error("Error uploading file:", error);
                    alert("Error uploading file. Check the console for details.");
                });
        });

    } else {
        console.error("Upload form not found in the DOM.");
    }
});
// #endregion

Update the Message Rendering Logic
Update your existing JavaScript  ReceiveMessage event handler to detect file links and render them as clickable links.
   
 connection.on("ReceiveMessage", function (user, message) {
    const li = document.createElement("li");

    // Check if the message is a file link (starts with '/uploads/')
    if (message.startsWith("/uploads/")) {
        const fileLink = document.createElement("a");
        fileLink.href = message;
        fileLink.textContent = message.split("/").pop(); // Display only the file name
        fileLink.target = "_blank"; // Open in a new tab

        li.textContent = `${user}: `;
        li.appendChild(fileLink);
    } else {
        li.textContent = `${user}: ${message}`;
    }

    document.getElementById("messagesList").appendChild(li);
});




To avoid the "sendMessage is not defined at button onclick" error, I had to add the following changes to my Script.
Moved the Script Inside the DOMContentLoaded Event Listener: In the corrected version, the DOMContentLoaded event listener was added around the entire script block to ensure that the script runs only after the page's DOM is fully loaded. This guarantees that all DOM elements, including the buttons and inputs, are accessible at the time the script executes.
javascript
CopyEdit
document.addEventListener("DOMContentLoaded", function () {
    // Entire script goes here
});


Changed the onclick="sendMessage()" to an Event Listener: Instead of using the onclick attribute directly in the HTML (<button onclick="sendMessage()">), the sendMessage function is now attached to the button via JavaScript using addEventListener inside the DOMContentLoaded event listener. This is done after the DOM elements are loaded, ensuring that the sendMessage function is available when the button is clicked.
javascript
CopyEdit
document.getElementById("sendButton").addEventListener("click", sendMessage);


Corrected String Interpolation for Messages: The message construction for ReceiveMessage, UserJoined, and UserLeft was incorrectly written using template literals without backticks. This caused the code to be syntactically incorrect. The corrected version uses backticks for string interpolation.
Example:
javascript
CopyEdit
const msg = `${user}: ${message}`;


Fixed the li.textContent Assignment: The code for assigning the li.textContent was repeated incorrectly. In the case of file messages, the textContent assignment was done first, and then it was overwritten by the next line of code. This was corrected so that the message is handled properly without overwriting content.
Example:
javascript
CopyEdit
li.textContent = `${user}: `;


These changes ensure the proper initialization of the sendMessage function and ensure that the events are properly bound to elements once the DOM is fully loaded.



bug_yellow_time.png

Add File Upload Handler
Place the OnPostAsync method in your Chat.cshtml.cs file 
#region OnPost Method Handler

public async Task<IActionResult> OnPostAsync(IFormFile file)
{
    if (file != null && file.Length > 0)
    {
        // Define the path to save the uploaded file
        var uploadsPath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", "uploads");

        // Ensure the 'uploads' directory exists
        if (!Directory.Exists(uploadsPath))
        {
            // Create the directory if it doesn't exist
            Directory.CreateDirectory(uploadsPath);
        }

        // Generate the file path (you can choose a different filename strategy here)
        var filePath = Path.Combine(uploadsPath, file.FileName);

        // Save the file to the server
        using (var stream = new FileStream(filePath, FileMode.Create))
        {
            await file.CopyToAsync(stream);
        }

        // Optionally, you can return the file path or some other information
        return Content($"File uploaded successfully: {file.FileName}");
    }
    else
    {
        return Content("No file selected.");
    }
}

#endregion OnPost Method Handler





Image successfully uploaded from UI to wwwroot/uploads



Add a preview area to show image before uploading & clear the file input and preview after successful submission
I needed to create a variable to store the uploaded file and another to manage the image preview section, where the image would be displayed before it was uploaded. To achieve this, I used the FileReader() method to capture the potential upload, and displayed it with readAsDataURL. I then set up a handler to manage the file upload submission. The form was stored in its own variable, formData, and I used the fetch method to send a POST request to the server with the file. If the upload was successful, the file input box and preview would be cleared.
Extracted and simplified version of the code related to the image preview functionality and clearing the file input after a successful submission:
document.addEventListener("DOMContentLoaded", function () {
    const uploadForm = document.querySelector("#uploadForm");

    if (!uploadForm) {
        console.error("Upload form not found.");
        return;
    }

    const fileInput = uploadForm.querySelector('input[type="file"]');
    const imagePreview = document.getElementById("imagePreview");

    // Display image preview before upload
    fileInput.addEventListener("change", function () {
        const file = fileInput.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = e => {
                imagePreview.src = e.target.result;
                imagePreview.style.display = "block"; // Show the preview
            };
            reader.readAsDataURL(file);
        } else {
            imagePreview.style.display = "none"; // Hide the preview if no file
            imagePreview.src = "";
        }
    });

    // Handle form submission (upload file)
    uploadForm.addEventListener("submit", function (event) {
        event.preventDefault();

        const formData = new FormData(uploadForm);
        fetch(uploadForm.action, {
            method: "POST",
            body: formData
        })
            .then(response => {
                if (response.ok) {
                    alert("File uploaded successfully!");
                    fileInput.value = ""; // Clear the file input
                    imagePreview.style.display = "none"; // Hide the image preview
                    imagePreview.src = ""; // Clear the image source
                } else {
                    alert("Error uploading file. Please try again.");
                }
            })
            .catch(error => console.error("Error uploading file:", error));
    });
});

Add this to place the image preview in the UI
<!-- Image Preview Section -->
<img id="imagePreview"/>


Preview Image Styling



<head>
      <style>
    #imagePreview { 
           width: 150px; /* Set the desired width */ 
          height: 150px; /* Set the desired height */ 
          object-fit: cover; /* Ensures the image is contained within the box without distortion 
           */ display: none; /* Hide the preview initially */ }
      </style>
  </head>

 <body>
 <!-- Your existing chat and file upload form goes here -->

To ensure file links persist as clickable
<ul id="messagesList">
    @foreach (var message in Model.Messages)
    {
        <li>
            <strong>@message.User</strong>: 
            @if (message.Content.StartsWith("/uploads/"))
            {
                @* Extract the file name from the path *@
                var fileName = System.IO.Path.GetFileName(message.Content);
                <a href="@message.Content" target="_blank">@fileName</a>
            }
            else
            {
                @message.Content
            }
            (@message.Timestamp)
        </li>
    }
</ul>


Update SignalR JavaScript Code:
In your JavaScript, modify the connection.on("ReceiveMessage", ...) handler to use Content instead of message:
connection.on("ReceiveMessage", function (user, content) {
    const li = document.createElement("li");

    if (content.startsWith("/uploads/")) {
        const fileLink = document.createElement("a");
        fileLink.href = content;
        fileLink.textContent = "Uploaded File";
        fileLink.target = "_blank"; // Open in a new tab

        li.textContent = `${user}: `;
        li.appendChild(fileLink);
    } else {
        li.textContent = `${user}: ${content}`;
    }

    document.getElementById("messagesList").appendChild(li);
});


Updated HTML 



<form id="chatForm" method="post" enctype="multipart/form-data" asp-antiforgery="true" action="/Chat">
    @Html.AntiForgeryToken()

    <div class="chat-container">
        <input type="text" id="messageInput" placeholder="Type your message..." />
        <label for="fileInput" class="file-upload">
            ðŸ“Ž
            <input type="file" id="fileInput" name="file" />
        </label>
        <button id="sendButton" type="button">Send</button>
    </div>
</form>


CSS for styling



<style>
    .chat-container {
        display: flex;
        align-items: center;
        gap: 8px;
        border: 1px solid #ccc;
        border-radius: 12px;
        padding: 8px 12px;
        background-color: #f9f9f9;
        max-width: 600px;
        margin: auto;
    }

    #messageInput {
        flex: 1;
        border: none;
        outline: none;
        font-size: 16px;
        padding: 8px;
        border-radius: 8px;
    }

    #messageInput::placeholder {
        color: #aaa;
    }

    .file-upload {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        font-size: 18px;
        color: #666;
        transition: background-color 0.2s ease;
    }

    .file-upload:hover {
        background-color: #e9e9e9;
    }

    .file-upload input[type="file"] {
        position: absolute;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
    }

    #sendButton {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.2s ease;
    }

    #sendButton:hover {
        background-color: #0056b3;
    }
</style>




Total Script including Uploads in message input box

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const fileInput = document.getElementById("fileInput");
        const imagePreview = document.getElementById("imagePreview");
        const user = "@User.Identity.Name"; // Get logged-in user's name
        const uploadForm = document.querySelector("#chatForm");

        if (!uploadForm) {
            console.error("Upload form not found.");
            return;
        }

        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/chatHub")
            .build();

        connection.on("ReceiveMessage", function (user, message) {
            const li = document.createElement("li");

            if (typeof message === "string" && message.startsWith("/uploads/")) {
                const fileLink = document.createElement("a");
                fileLink.href = message;
                fileLink.textContent = message.split("/").pop(); // Extract the file name
                fileLink.target = "_blank";

                li.textContent = `${user}: `;
                li.appendChild(fileLink);
            } else if (typeof message === "string") {
                li.textContent = `${user}: ${message}`;
            } else {
                console.error("Invalid message received:", message);
                li.textContent = `${user}: [Error: Invalid message]`;
            }

            document.getElementById("messagesList").appendChild(li);
        });

        connection.on("UserJoined", function (user) {
            const msg = `${user} has joined the chat.`;
            const li = document.createElement("li");
            li.textContent = msg;
            document.getElementById("messagesList").appendChild(li);
        });

        connection.on("UserLeft", function (user) {
            const msg = `${user} has left the chat.`;
            const li = document.createElement("li");
            li.textContent = msg;
            document.getElementById("messagesList").appendChild(li);
        });

        connection.on("OnlineUsers", function (users) {
            const userList = document.getElementById("onlineUsers");
            userList.innerHTML = ""; // Clear the list
            users.forEach(function (user) {
                const li = document.createElement("li");
                li.textContent = user;
                userList.appendChild(li);
            });
        });

        connection.start().then(() => {
            connection.invoke("GetOnlineUsers");
        }).catch(err => console.error(err.toString()));

        function sendMessage() {
            const message = document.getElementById("messageInput").value;

            if (fileInput.files[0]) {
                const formData = new FormData();
                const token = uploadForm.querySelector('input[name="__RequestVerificationToken"]').value;

                formData.append("file", fileInput.files[0]);
                formData.append("__RequestVerificationToken", token);

                fetch("/Chat", {
                    method: "POST",
                    body: formData,
                    headers: {
                        "Accept": "application/json"
                    },
                })
                    .then((response) => {
                        if (response.ok) {
                            alert("File uploaded successfully!");
                            fileInput.value = "";
                            imagePreview.style.display = "none";
                            imagePreview.src = "";

                            connection.invoke("SendMessage", user, message).catch((err) => {
                                console.error(err.toString());
                            });

                            document.getElementById("messageInput").value = "";
                        } else {
                            return response.text().then((error) => {
                                console.error("Upload failed:", error);
                                alert("Error uploading file: " + error);
                            });
                        }
                    })
                    .catch((error) => console.error("Error uploading file:", error));
            } else {
                connection.invoke("SendMessage", user, message).catch((err) => {
                    console.error(err.toString());
                });

                document.getElementById("messageInput").value = "";
            }
        }

        document.getElementById("sendButton").addEventListener("click", sendMessage);

        fileInput.addEventListener("change", function () {
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    imagePreview.src = e.target.result;
                    imagePreview.style.display = "block";
                };
                reader.readAsDataURL(file);
            } else {
                imagePreview.style.display = "none";
                imagePreview.src = "";
            }
        });

        uploadForm.addEventListener("submit", function (event) {
            event.preventDefault();

            const formData = new FormData(uploadForm);

            fetch(uploadForm.action, {
                method: "POST",
                body: formData
            })
                .then(response => {
                    if (response.ok) {
                        alert("File uploaded successfully!");
                        fileInput.value = "";
                        imagePreview.style.display = "none";
                        imagePreview.src = "";
                    } else {
                        alert("Error uploading file. Please try again.");
                    }
                })
                .catch(error => console.error("Error uploading file:", error));
        });
    });
</script>




Preview image displays in message container

Full Chat Page


@page
@model ChatApp.Pages.Chat.ChatModel
@using Microsoft.AspNetCore.Authorization
@attribute [Authorize]  // This restricts access to authenticated users

<head>
    <style>
   .chat-container {
    display: flex;
    align-items: center;
    gap: 8px;
    border: 1px solid #ccc;
    border-radius: 12px;
    padding: 8px 12px;
    background-color: #f9f9f9;
    max-width: 600px;
    margin: auto;
    position: relative; /* Ensure positioning context for elements inside */
}

#messageInput {
    flex: 1;
    border: none;
    outline: none;
    font-size: 16px; /* Font size for input */
    padding: 8px 50px 8px 8px; /* Padding for the right to make room for the image */
    border-radius: 8px;
    position: relative; /* Position context for the image */
    height: auto; /* Let the height grow dynamically */
    box-sizing: border-box; /* Include padding in width calculation */
    transition: padding-right 0.2s ease, font-size 0.2s ease; /* Smooth transition for both padding and font size */
}

#messageInput::placeholder {
    color: #aaa;
}

#imagePreview {
    position: relative;
    right: 10px; /* Keep it 10px from the right edge */
    top: 50%;
    width: 170px; /* Default width of the image */
    height: 160px; /* Default height of the image */
    object-fit: cover;
    display: none; /* Initially hidden */
    transition: width 0.2s ease, height 0.2s ease; /* Smooth transition for size change */
}

#messageInput:focus + .file-upload {
    /* Optional: style when input is focused */
    box-shadow: 0 0 4px rgba(0, 123, 255, 0.5);
}

.file-upload {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    font-size: 18px;
    color: #666;
    transition: background-color 0.2s ease;
}

.file-upload:hover {
    background-color: #e9e9e9;
}

.file-upload input[type="file"] {
    position: absolute;
    opacity: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
}

#sendButton {
    background-color: #007bff;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px; /* Adjust font size for send button */
    transition: background-color 0.2s ease, font-size 0.2s ease; /* Smooth transition for button font size */
}

#sendButton:hover {
    background-color: #0056b3;
}

    </style
</head>

<body>

<h2>Chat Room</h2>
<!-- Display online users -->
<h3>Online Users</h3>
<ul id="onlineUsers"></ul>

    <ul id="messagesList">
        @foreach (var message in Model.Messages)
        {
            <li>
                <strong>@message.User</strong>:
                @if (message.Content.StartsWith("/uploads/"))
                {
                    @* Extract the file name from the path *@
                    var fileName = System.IO.Path.GetFileName(message.Content);
                    <a href="@message.Content" target="_blank">@fileName</a>
                }
                else
                {
                    @message.Content
                }
                (@message.Timestamp)
            </li>
        }
    </ul>



<!-- Chat UI here -->
<form id="chatForm" method="post" enctype="multipart/form-data" asp-antiforgery="true" action="/Chat">
        @Html.AntiForgeryToken()

        <div class="chat-container">
            <input type="text" id="messageInput" placeholder="Type your message..." />
            <label for="fileInput" class="file-upload">
                ðŸ“Ž
                <input type="file" id="fileInput" name="file" />
            </label>
            <button id="sendButton" type="button">Send</button>
            <img id="imagePreview" />
        </div>
    </form>

<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.0/signalr.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const fileInput = document.getElementById("fileInput");
            const imagePreview = document.getElementById("imagePreview");
            const user = "@User.Identity.Name"; // Get logged-in user's name
            const uploadForm = document.querySelector("#chatForm");

            if (!uploadForm) {
                console.error("Upload form not found.");
                return;
            }

            const connection = new signalR.HubConnectionBuilder()
                .withUrl("/chatHub")
                .build();

            connection.on("ReceiveMessage", function (user, message) {
                const li = document.createElement("li");

                if (typeof message === "string" && message.startsWith("/uploads/")) {
                    const fileLink = document.createElement("a");
                    fileLink.href = message;
                    fileLink.textContent = message.split("/").pop(); // Extract the file name
                    fileLink.target = "_blank";

                    li.textContent = `${user}: `;
                    li.appendChild(fileLink);
                } else if (typeof message === "string") {
                    li.textContent = `${user}: ${message}`;
                } else {
                    console.error("Invalid message received:", message);
                    li.textContent = `${user}: [Error: Invalid message]`;
                }

                document.getElementById("messagesList").appendChild(li);
            });

            connection.on("UserJoined", function (user) {
                const msg = `${user} has joined the chat.`;
                const li = document.createElement("li");
                li.textContent = msg;
                document.getElementById("messagesList").appendChild(li);
            });

            connection.on("UserLeft", function (user) {
                const msg = `${user} has left the chat.`;
                const li = document.createElement("li");
                li.textContent = msg;
                document.getElementById("messagesList").appendChild(li);
            });

            connection.on("OnlineUsers", function (users) {
                const userList = document.getElementById("onlineUsers");
                userList.innerHTML = ""; // Clear the list
                users.forEach(function (user) {
                    const li = document.createElement("li");
                    li.textContent = user;
                    userList.appendChild(li);
                });
            });

            connection.start().then(() => {
                connection.invoke("GetOnlineUsers");
            }).catch(err => console.error(err.toString()));

            function sendMessage() {
                const message = document.getElementById("messageInput").value;

                if (fileInput.files[0]) {
                    const formData = new FormData();
                    const token = uploadForm.querySelector('input[name="__RequestVerificationToken"]').value;

                    formData.append("file", fileInput.files[0]);
                    formData.append("__RequestVerificationToken", token);

                    fetch("/Chat", {
                        method: "POST",
                        body: formData,
                        headers: {
                            "Accept": "application/json"
                        },
                    })
                        .then((response) => {
                            if (response.ok) {
                                alert("File uploaded successfully!");
                                fileInput.value = "";
                                imagePreview.style.display = "none";
                                imagePreview.src = "";

                                connection.invoke("SendMessage", user, message).catch((err) => {
                                    console.error(err.toString());
                                });

                                document.getElementById("messageInput").value = "";
                            } else {
                                return response.text().then((error) => {
                                    console.error("Upload failed:", error);
                                    alert("Error uploading file: " + error);
                                });
                            }
                        })
                        .catch((error) => console.error("Error uploading file:", error));
                } else {
                    connection.invoke("SendMessage", user, message).catch((err) => {
                        console.error(err.toString());
                    });

                    document.getElementById("messageInput").value = "";
                }
            }

            document.getElementById("sendButton").addEventListener("click", sendMessage);

            fileInput.addEventListener("change", function () {
                const file = fileInput.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        imagePreview.src = e.target.result;
                        imagePreview.style.display = "block"; // Show the preview
                    };
                    reader.readAsDataURL(file);
                } else {
                    imagePreview.style.display = "none";
                    imagePreview.src = "";
                }
            });

            uploadForm.addEventListener("submit", function (event) {
                event.preventDefault();

                const formData = new FormData(uploadForm);

                fetch(uploadForm.action, {
                    method: "POST",
                    body: formData
                })
                    .then(response => {
                        if (response.ok) {
                            alert("File uploaded successfully!");
                            fileInput.value = "";
                            imagePreview.style.display = "none";
                            imagePreview.src = "";
                        } else {
                            alert("Error uploading file. Please try again.");
                        }
                    })
                    .catch(error => console.error("Error uploading file:", error));
            });
        });
    </script>

</body>





â†â€”------------------------------------------------------------------------->
Display uploaded images in the clientâ€™s messages and persist them for future sessions
Add an entry in your Message model to store the file path or URL for the uploaded image. This will allow the app to distinguish between text messages and media.


public class Message
{
    public int Id { get; set; }
    public string User { get; set; }
    public string Content { get; set; } // Message text or file path
    public DateTime Timestamp { get; set; }
    public bool IsMedia { get; set; } = false; // Indicates if the message is media
}



Adding a new property like IsMedia to your Message class requires a migration because it changes the structure of the database table. Entity Framework (EF) needs to know about this change so it can update the database schema accordingly.

dotnet ef migrations add AddIsMediaToMessage



dotnet ef database update

Update the Razor Page's PageModel: Add methods to handle file uploads and message retrieval.

public class ChatModel : PageModel
{
    private readonly AppDbContext _context;

    public ChatModel(AppDbContext context)
    {
        _context = context;
    }

    [BindProperty]
    public IFormFile UploadedFile { get; set; }

    public List<Message> Messages { get; set; }

public async Task OnGetAsync()
{
    Messages = await _context.Messages.OrderBy(m => m.Timestamp).ToListAsync();

    if (_hubContext != null)
    {
        await _hubContext.Clients.All.SendAsync("ReceiveMessage", "Server",
            "Welcome to the chat!");
    }
    else
    {
        Console.WriteLine("SignalR context is not available.");
    }
}

public async Task<IActionResult> OnPostAsync(IFormFile file)
{
    if (file != null && file.Length > 0)
    {
        try
        {
            // Define the path to save the uploaded file
            var uploadsPath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", "uploads");

            // Ensure the 'uploads' directory exists
            if (!Directory.Exists(uploadsPath))
            {
                Directory.CreateDirectory(uploadsPath);
            }

            // Validate file type
            var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif" };
            var fileExtension = Path.GetExtension(file.FileName).ToLower();

            if (!allowedExtensions.Contains(fileExtension))
            {
                return new JsonResult(new { success = false, error = "Invalid file type." });
            }

            // Sanitize and generate a unique filename
            var sanitizedFileName = string.Concat(file.FileName.Split(Path.GetInvalidFileNameChars()));
            var uniqueFileName = Guid.NewGuid() + Path.GetExtension(sanitizedFileName);
            var filePath = Path.Combine(uploadsPath, uniqueFileName);

            // Save the file to the server
            using (var stream = new FileStream(filePath, FileMode.Create))
            {
                await file.CopyToAsync(stream);
            }

            // Save the file information to the database
            var message = new Message
            {
                Content = $"/uploads/{uniqueFileName}", // Save relative path for serving
                User = User.Identity?.Name ?? "Anonymous",
                Timestamp = DateTime.Now,
                IsMedia = true // Indicate this is a media file
            };

            _context.Messages.Add(message); // Add the message to the database
            await _context.SaveChangesAsync(); // Save changes to the database

            // Notify SignalR clients
            await _hubContext.Clients.All.SendAsync("ReceiveMessage", message.User, message.Content);

            // Return success JSON response
            return new JsonResult(new
            {
                success = true,
                message = "File uploaded successfully",
                filePath = message.Content
            })
            {
                ContentType = "application/json"
            };
        }
        catch (Exception ex)
        {
            // Handle exceptions gracefully
            return new JsonResult(new { success = false, error = "File upload failed", details = ex.Message });
        }
    }

    return new JsonResult(new { success = false, error = "No file selected." });
}

public async Task<IActionResult> OnPostSendMessageAsync(string messageContent)
{
    if (string.IsNullOrWhiteSpace(messageContent))
    {
        ModelState.AddModelError(string.Empty, "Message content cannot be empty.");
        return Page();
    }

    var message = new Message
    {
        User = User.Identity?.Name ?? "Anonymous", // Handle cases where the user is not authenticated
        Content = messageContent,
        Timestamp = DateTime.UtcNow,
        IsMedia = false // Indicate this is a text message
    };

    // Save the message to the database
    _context.Messages.Add(message);
    await _context.SaveChangesAsync();

    // Notify all SignalR clients about the new message
    await _hubContext.Clients.All.SendAsync("ReceiveMessage", message.User, message.Content);

    // Redirect to refresh the page or return a success result
    return RedirectToPage();
}



Update Razor Page Markup: Update your Razor Page to handle both text and file messages.
<h2>Chat Room</h2>

<!-- Display online users -->
<h3>Online Users</h3>
<ul id="onlineUsers" class="user-list"></ul>

<!-- Display messages -->
<ul id="messagesList" class="messages-list">
    @foreach (var message in Model.Messages)
    {
        <li class="message-item">
            <strong>@message.User</strong>:
            @if (message.Content.StartsWith("/uploads/"))
            {
                var fileExtension = System.IO.Path.GetExtension(message.Content).ToLower();
                if (fileExtension == ".jpg" || fileExtension == ".png" || fileExtension == ".gif")
                {
                    <img src="@message.Content" alt="Uploaded Image" class="message-image" />
                }
                else
                {
                    var fileName = System.IO.Path.GetFileName(message.Content);
                    <a href="@message.Content" target="_blank">@fileName</a>
                }
            }
            else
            {
                @message.Content
            }
            <span class="timestamp">(@message.Timestamp.ToString("MMM dd, yyyy h:mm tt"))</span>
        </li>
    }
</ul>

<!-- Chat UI -->
<form id="chatForm" method="post" enctype="multipart/form-data" asp-antiforgery="true" action="/Chat">
    @Html.AntiForgeryToken()

    <div class="chat-container">
        <input type="text" id="messageInput" placeholder="Type your message..." />
        <label for="fileInput" class="file-upload" aria-label="Attach a file">
            ðŸ“Ž
            <input type="file" id="fileInput" name="file" />
        </label>
        <button id="sendButton" type="button">Send</button>
        <img id="imagePreview" />
    </div>
</form>


Update JavaScript

In Razor Pages, the OnPostAsync method is tied directly to the page's URL, meaning the endpoint for handling a POST request corresponds to the Razor Page's route, which is derived from the page's file location rather than the class name (e.g., /Chat for Chat.cshtml). When using JavaScript to submit a form or send a POST request via fetch, it is crucial to ensure the endpoint matches the page's URL. In this case, using the endpoint "/Chat" in the fetch call correctly aligns with the Razor Page's route, ensuring the request is routed to the appropriate handler.
fetch is a modern JavaScript API used to make asynchronous HTTP requests from the browser to a server. It provides a flexible and easy-to-use method for retrieving resources or sending data without needing to reload the entire page. Unlike older technologies like XMLHttpRequest, fetch returns a Promise, making it easier to work with asynchronous code using .then(), .catch(), or async/await syntax. It supports all common HTTP methods (GET, POST, PUT, DELETE, etc.) and allows for sending data, such as form data or JSON, to the server. With fetch, developers can create dynamic, interactive web applications by fetching data in the background and updating the page without interrupting the user's experience.
document.addEventListener("DOMContentLoaded", function () {
    const uploadForm = document.querySelector("#uploadForm");

    uploadForm.addEventListener("submit", async (event) => {
        event.preventDefault();

        const formData = new FormData(uploadForm);
        try {
            const response = await fetch("/Chat", { // Adjusted endpoint
                method: "POST",
                body: formData,
            });

            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }

            // Try to parse JSON response
            let result;
            try {
                result = await response.json();
            } catch (jsonError) {
                console.error("JSON parse error:", jsonError);
                alert("Unexpected response format. Check the console for details.");
                return;
            }

            // Handle result
            if (result.success) {
                alert(`File uploaded successfully: ${result.filePath}`);
                const li = document.createElement("li");
                li.innerHTML = `<strong>Uploaded:</strong> <a href="${result.filePath}" target="_blank">${result.filePath}</a>`;
                document.querySelector("#messagesList").appendChild(li);
            } else {
                alert(`Server error: ${result.error}`);
            }
        } catch (error) {
            console.error("Upload failed:", error);
            alert("An unexpected error occurred. Check the console for details.");
        }
    });
});

Asynchronous Form Submission:

uploadForm.addEventListener("submit", async (event) => {
    event.preventDefault();
    const formData = new FormData(uploadForm);

The form submission handler is converted into an asynchronous function to handle API responses with await.
POST Request to Server:
javascript
CopyEdit
const response = await fetch("/Chat/OnPostAsync", {
    method: "POST",
    body: formData,
});
const result = await response.json();

The file upload request is made using fetch to the server endpoint /Chat/OnPostAsync, and the JSON response is parsed.
Success Response Handling:
javascript
CopyEdit
if (result.success) {
    alert(`File uploaded successfully: ${result.filePath}`);
    // Optionally append the file message to the chat
    const li = document.createElement("li");
    li.textContent = `Uploaded: ${result.filePath}`;
    document.querySelector("#messagesList").appendChild(li);
}

On success, an alert displays the uploaded file path, and a new <li> element is appended to the chat's message list, displaying the file's path.
Error Response Handling:
else {
    alert(`Error: ${result.error}`);
}

If the server returns an error, the error message is displayed in an alert.
Enhanced Error Handling:
catch (error) {
    console.error("Upload failed:", error);
    alert("An unexpected error occurred. Check the console for details.");
}

A try-catch block wraps the fetch logic to gracefully handle unexpected errors, logging them to the console and showing a user-friendly alert.
Removed Image Preview Handling:
The image preview functionality from the previous script was removed to focus on uploading files and updating the chat message list.
Display Uploaded Images in the Client
<ul id="messagesList">
    @foreach (var message in Model.Messages)
    {
        if (message.IsMedia)
        {
            <li>
                <strong>@message.User</strong>: <img src="@message.Content" alt="Uploaded image" style="max-width: 300px; max-height: 300px;" />
                <span>(@message.Timestamp)</span>
            </li>
        }
        else
        {
            <li>
                <strong>@message.User</strong>: @message.Content
                <span>(@message.Timestamp)</span>
            </li>
        }
    }
</ul>






Broadcast the Uploaded Image

Modify the SignalR SendMessage method in ChatHub to send image messages:
public async Task SendMessage(string user, string message, bool isMedia = false)
{
    // Create a new message object
    var newMessage = new Message
    {
        User = user,
        Content = message, // This could be text or a file URL
        Timestamp = DateTime.Now,
        IsMedia = isMedia // Indicate if this message is a media file
    };

    // Add the new message to the database
    _dbContext.Messages.Add(newMessage);
    await _dbContext.SaveChangesAsync();

    // Broadcast the message to all connected clients
    await Clients.All.SendAsync("ReceiveMessage", user, message, isMedia);
}

Client-Side Integration

Update JavaScript to handle media messages:
connection.on("ReceiveMessage", function (user, message, isMedia) {
    const li = document.createElement("li");
    if (isMedia) {
        li.innerHTML = `<strong>${user}</strong>: <img src="${message}" alt="Uploaded image" style="max-width: 300px; max-height: 300px;">`;
    } else {
        li.textContent = `${user}: ${message}`;
    }
    document.getElementById("messagesList").appendChild(li);
});


Handling File Uploads
What Changed
SignalR Integration:
After saving the uploaded file, the method uses IHubContext<ChatHub> to broadcast the file's URL to all clients in real-time.
The SendAsync method sends the username, file URL, and isMedia flag.
Use of a Unique File Name:
Ensures that uploaded files donâ€™t overwrite existing ones.
Relative Path Handling:
Stores the file's relative path (/uploads/filename.ext) in the database for easy client access.
Dynamic Hub Context:
Retrieves the IHubContext<ChatHub> service dynamically to broadcast messages. This avoids coupling the Razor Page directly with the SignalR hub.

Image persists between sessions



â†â€”--------------------------------------------------------------------------------------------------------------->


Steps to Implement Private Messaging

Add the following declaration at the top of the Chathub class:

private static readonly Dictionary<string, string> ConnectedUsers = new();

 Update the ChatHub to Handle Private Messages
You need to define a method in your SignalR hub to send private messages between users. 
public async Task SendPrivateMessage(string recipientUserName, string message)
{
    var senderUserName = Context.User?.Identity?.Name ?? Context.ConnectionId;

    // Find the connection ID of the recipient
    if (ConnectedUsers.TryGetValue(recipientUserName, out var recipientConnectionId))
    {
        // Send the private message to the recipient
        await Clients.Client(recipientConnectionId).SendAsync("ReceivePrivateMessage", senderUserName, message);

        // Optionally, send an acknowledgment to the sender
        await Clients.Caller.SendAsync("PrivateMessageSent", recipientUserName, message);
    }
    else
    {
        // Inform the sender if the recipient is not online
        await Clients.Caller.SendAsync("UserNotAvailable", recipientUserName);
    }
}


Update the ChatHub to Maintain a User Connection Map
Modify your hub to keep track of which user is connected to which connection ID. 
// Dictionary to map usernames to connection IDs
private static readonly Dictionary<string, string> ConnectedUsers = new();

public override async Task OnConnectedAsync()
{
    var userName = Context.User?.Identity?.Name ?? Context.ConnectionId;
    ConnectedUsers[userName] = Context.ConnectionId;

    // Notify all users about the updated online list
    await Clients.All.SendAsync("UpdateOnlineUsers", ConnectedUsers.Keys);
    await base.OnConnectedAsync();
}

public override async Task OnDisconnectedAsync(Exception exception)
{
    var userName = ConnectedUsers.FirstOrDefault(x => x.Value == Context.ConnectionId).Key;
    if (userName != null)
    {
        ConnectedUsers.Remove(userName);
        await Clients.All.SendAsync("UpdateOnlineUsers", ConnectedUsers.Keys);
    }

    await base.OnDisconnectedAsync(exception);
}


Update the Front-End to Handle Private Messaging
Ensure your client-side JavaScript (or your preferred framework) can handle sending and receiving private messages:
function sendPrivateMessage(recipientUserName, message) {
    connection.invoke("SendPrivateMessage", recipientUserName, message)
        .catch(err => console.error(err.toString()));
}
To receive a private message
connection.on("ReceivePrivateMessage", (senderUserName, message) => {
    console.log(`Private message from ${senderUserName}: ${message}`);
    // Add code to display the private message in the UI
});
Update Message Class

public class Message
{
    public int Id { get; set; }
    public string User { get; set; }
    public string Content { get; set; }
    public DateTime Timestamp { get; set; }
   public bool IsMedia { get; set; }
    public bool IsPrivate { get; set; } // True for private messages
    public string? Recipient { get; set; } // Null for public messages
}

Update SendMessage



public async Task SendMessage(string user, string message, bool isMedia = false, string? recipientUserName = null)
{
    // Create a new message object
    var newMessage = new Message
    {
        User = user,
        Content = message, // This could be text or a file URL
        Timestamp = DateTime.Now,
        IsMedia = isMedia, // Indicate if this message is a media file
        IsPrivate = !string.IsNullOrEmpty(recipientUserName), // Mark as private if recipient is specified
        Recipient = recipientUserName // Save the recipient if private
    };

    // Add the new message to the database
    _dbContext.Messages.Add(newMessage);
    await _dbContext.SaveChangesAsync();

    if (!string.IsNullOrEmpty(recipientUserName) && ConnectedUsers.TryGetValue(recipientUserName, out var recipientConnectionId))
    {
        // Send private message to recipient
        await Clients.Client(recipientConnectionId).SendAsync("ReceiveMessage", user, message, isMedia);
    }
    else
    {
        // Broadcast the message to all connected clients if not private
        await Clients.All.SendAsync("ReceiveMessage", user, message, isMedia);
    }
}

Update OnGetAsync() in Chat Model.
public async Task OnGetAsync()
{
    var currentUser = User.Identity?.Name;
    Messages = await _context.Messages
        .Where(m => !m.IsPrivate || m.User == currentUser || m.Recipient == currentUser)
        .OrderBy(m => m.Timestamp)
        .ToListAsync();
}


you'll need to update Chat.cshtml to support private messages
Specify the recipient of a private message:
@page "/Chat"
@model ChatApp.Pages.Chat.ChatModel
@using Microsoft.AspNetCore.Authorization
@attribute [Authorize]  // Restrict access to authenticated users

<h2>Chat Room</h2>

<h3>Online Users</h3>
<ul id="onlineUsers"></ul>

<form id="fileUploadForm" action="/Chat?handler=UploadFile" method="post" enctype="multipart/form-data">
    @Html.AntiForgeryToken()  <!-- Add the anti-forgery token here -->
    <input type="file" id="fileInput" name="file" />
    <button type="submit">Upload</button>
</form>

<ul id="messagesList">
    @foreach (var message in Model.Messages)
    {
        if (message.IsMedia)
        {
            <li>
                <strong>@message.User</strong>: <img src="@message.Content" alt="Uploaded image" style="max-width: 300px; max-height: 300px;" />
                <span>(@message.Timestamp)</span>
            </li>
        }
        else
        {
            <li>
                <strong>@message.User</strong>: @message.Content
                <span>(@message.Timestamp)</span>
            </li>
        }
    }
</ul>

<!-- Display the signed-in user's name in the message input -->
<p><strong>Your name: </strong>@Model.CurrentUserName</p>

<!-- Public message input -->
<input type="text" id="messageInput" placeholder="Type your message..." />
<button onclick="sendMessage()">Send</button>

<hr />

<!-- Private messaging section -->
<h3>Private Messaging</h3>
<div>
    <input type="text" id="privateRecipient" placeholder="Recipient Username" />
    <input type="text" id="privateMessageInput" placeholder="Type your private message..." />
    <button onclick="sendPrivateMessage()">Send Private Message</button>
</div>


Handle Private Messages in JavaScript
document.getElementById("sendPrivateMessage").addEventListener("click", function () {
    const recipient = document.getElementById("privateRecipient").value;
    const message = document.getElementById("privateMessage").value;

    if (recipient && message) {
        sendPrivateMessage(recipient, message);

        // Optionally, clear the input fields after sending
        document.getElementById("privateRecipient").value = "";
        document.getElementById("privateMessage").value = "";
    } else {
        alert("Please enter both a recipient and a message.");
    }
});




Full & Tidied up JavaScript



<script>
    // ========================== //
    // SignalR Connection Setup   //
    // ========================== //

    const connection = new signalR.HubConnectionBuilder()
        .withUrl("/chatHub")
        .build();

    // ============================== //
    // SignalR Event Listeners        //
    // ============================== //

    // Handle receiving a public message
    connection.on("ReceiveMessage", function (user, message, isMedia) {
        const li = document.createElement("li");
        if (isMedia) {
            li.innerHTML = `<strong>${user}</strong>: <img src="${message}" alt="Uploaded media" style="max-width: 300px; max-height: 300px;">`;
        } else {
            li.textContent = `${user}: ${message}`;
        }
        document.getElementById("messagesList").appendChild(li);
    });

    // Handle user joining the chat
    connection.on("UserJoined", function (user) {
        const msg = `${user} has joined the chat.`;
        const li = document.createElement("li");
        li.textContent = msg;
        document.getElementById("messagesList").appendChild(li);
    });

    // Handle user leaving the chat
    connection.on("UserLeft", function (user) {
        const msg = `${user} has left the chat.`;
        const li = document.createElement("li");
        li.textContent = msg;
        document.getElementById("messagesList").appendChild(li);
    });

    // Handle list of online users
    connection.on("OnlineUsers", function (users) {
        const userList = document.getElementById("onlineUsers");
        userList.innerHTML = ""; // Clear the list
        users.forEach(function (user) {
            const li = document.createElement("li");
            li.textContent = user;
            userList.appendChild(li);
        });
    });

    // Handle receiving a private message
    connection.on("ReceivePrivateMessage", (senderUserName, message) => {
        const privateLi = document.createElement("li");
        privateLi.innerHTML = `<strong>${senderUserName} (private)</strong>: ${message}`;
        document.getElementById("messagesList").appendChild(privateLi);
    });

    // ============================ //
    // Connection Start and Handlers //
    // ============================ //

    // Start the SignalR connection and fetch online users
    connection.start().then(() => {
        connection.invoke("GetOnlineUsers");
    }).catch(err => console.error(err.toString()));

    // ============================ //
    // File Upload Event Listener    //
    // ============================ //

    document.getElementById('fileUploadForm').addEventListener('submit', function (event) {
        event.preventDefault(); // Prevent the default form submission

        var fileInput = document.getElementById('fileInput');
        var file = fileInput.files[0]; // Get the selected file

        if (file) {
            const formData = new FormData();
            formData.append("file", file);

            // Add the anti-forgery token manually if using fetch
            var token = document.querySelector('input[name="__RequestVerificationToken"]').value;
            formData.append("__RequestVerificationToken", token);

            fetch("/Chat?handler=UploadFile", {
                method: "POST",
                body: formData
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.filePath) {
                        console.log("File uploaded to:", data.filePath);
                    } else if (data.error) {
                        console.error("Upload failed:", data.error);
                    }
                })
                .catch(err => console.error("Error uploading file:", err));
        } else {
            console.error("No file selected.");
        }
    });

    // ============================== //
    // Public Messaging Functionality //
    // ============================== //

    function sendMessage() {
        const messageInput = document.getElementById("messageInput");
        const message = messageInput.value;

        if (message.trim() !== "") {
            connection.invoke("SendMessage", "@Model.CurrentUserName", message)
                .catch(err => console.error(err.toString()));

            // Clear the input after sending
            messageInput.value = "";

            // Optionally, append the message to the list on the client-side
            const li = document.createElement("li");
            li.textContent = `You: ${message}`;
            document.getElementById("messagesList").appendChild(li);
        } else {
            console.error("Cannot send an empty message.");
        }
    }

    // ================================ //
    // Private Messaging Functionality  //
    // ================================ //

    function sendPrivateMessage() {
        const recipientInput = document.getElementById("privateRecipient");
        const privateMessageInput = document.getElementById("privateMessageInput");

        const recipient = recipientInput.value.trim();
        const message = privateMessageInput.value.trim();

        if (recipient && message) {
            connection.invoke("SendPrivateMessage", recipient, message)
                .catch(err => console.error(err.toString()));

            // Clear the private message input after sending
            privateMessageInput.value = "";
        } else {
            alert("Please enter both recipient username and message.");
        }
    }
</script>


Full HTML


@page "/Chat"
@model ChatApp.Pages.Chat.ChatModel
@using Microsoft.AspNetCore.Authorization
@attribute [Authorize]

<head>
    <style>
        .private-message {
            background-color: #f0f8ff;
            padding: 5px;
            border-radius: 5px;
            margin: 5px 0;
            font-style: italic;
        }
    </style>
</head>

<h2>Chat Room</h2>

<h3>Online Users</h3>
<ul id="onlineUsers"></ul>

<form id="fileUploadForm" action="/Chat?handler=UploadFile" method="post" enctype="multipart/form-data">
    @Html.AntiForgeryToken()  <!-- Add the anti-forgery token here -->
    <input type="file" id="fileInput" name="file" />
    <button type="submit">Upload</button>
</form>

<ul id="messagesList">
    @foreach (var message in Model.Messages)
    {
        if (message.IsMedia)
        {
            <li>
                <strong>@message.User</strong>: <img src="@message.Content" alt="Uploaded image" style="max-width: 300px; max-height: 300px;" />
                <span>(@message.Timestamp)</span>
            </li>
        }
        else
        {
            <li class="@(message.Recipient != null ? "private-message" : "")">
                <strong>@message.User</strong>: @message.Content
                <span>(@message.Timestamp)</span>
                @if (!string.IsNullOrEmpty(message.Recipient))
                {
                    <em>(Private to: @message.Recipient)</em>
                }
            </li>
        }
    }
</ul>

<!-- Display the signed-in user's name in the message input -->
<p><strong>Your name: </strong>@Model.CurrentUserName</p>

<input type="text" id="messageInput" placeholder="Type your message..." />
<button onclick="sendMessage()">Send</button>

<div>
    <input type="text" id="privateRecipient" placeholder="Recipient Username" />
    <input type="text" id="privateMessageInput" placeholder="Type your private message here..." />
    <button onclick="sendPrivateMessage()">Send Private Message</button>
</div>





















 Persistent Storage for Messages: Currently, my messages are stored in memory or temporarily in the session. I aim to persist them in a database so they can be accessed even after the application restarts. Iâ€™ll add a Message entity to the AppDbContext and set up migrations to store messages in my SQLite database, ensuring they are saved permanently.
 Real-time Updates for New Users: I want to enhance the real-time experience by notifying all connected clients when a new user joins or leaves the chat. Iâ€™ll create UserJoined and UserLeft events in the SignalR Hub to broadcast these updates to all clients.
 Message Formatting and Rich Media: I plan to allow users to send images, videos, or files within messages. This would involve implementing file upload functionality and sending URLs or file paths to the server, allowing other clients to view or download the media.
 Private Messages: I also want to implement private messaging, allowing users to send messages to each other privately. This will involve modifying the SignalR hub to handle private message channels, where only the sender and the recipient can see the message.
 Message History & Pagination: As the app grows, I plan to implement pagination for message history so that users donâ€™t have to load thousands of messages at once. I could create a "load more messages" feature where users can scroll to the top of the chat and load previous messages in chunks.
User Profiles and Avatars: Another feature Iâ€™d like to add is user profiles, which may include custom avatars or display names. These details will be stored in the database and displayed in the chat UI alongside the messages.
Error Handling and Validation: To improve the appâ€™s robustness, Iâ€™ll add proper error handling and input validation both on the client and server sides. This will include ensuring messages arenâ€™t empty and handling cases where users disconnect or attempt to send invalid data.
Testing: I plan to implement unit and integration tests for key components of the app using tools like xUnit or NUnit for backend testing, and Selenium or Playwright for frontend testing.
Deploy to Production: Once the app is stable, Iâ€™ll look into deploying it to a cloud platform like Azure, AWS, or Heroku. This will involve setting up environment variables and ensuring the database connection string is securely handled.
Security Enhancements: Finally, I will secure the app further by implementing features such as rate-limiting to prevent spam, CSRF protection, and HTTPS for encrypted communication.


